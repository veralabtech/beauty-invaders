<!doctype html>
<html lang="it">

<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Beauty Invaders — spara ai trucchi!</title>
  <style>
    :root {
      --bg: #0f1724;
      --panel: #0b1220aa;
      --accent: #ff7aa2;
      --text: #f8fafc;
    }

    html,
    body {
      font-family: system-ui, -apple-system, Segoe UI, Roboto, "Helvetica Neue", Arial;
      height: 100%;
      margin: 0;
      overflow: hidden;
    }

    body {
      background: radial-gradient(closest-side, #071028 0%, var(--bg) 60%);
      color: var(--text);
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 16px;
    }

    @media(max-width:880px) {
      body {
        padding: 0;
      }
    }

    .wrap {
      width: 100%;
      height: 100%;
      max-width: 900px;
      max-height: 900px;
      /* Limit height on large screens */
      background: linear-gradient(180deg, rgba(255, 255, 255, 0.03), rgba(0, 0, 0, 0.15));
      border-radius: 12px;
      box-shadow: 0 10px 30px rgba(2, 6, 23, 0.6);
      padding: 12px;
      display: flex;
      flex-direction: row;
      gap: 12px;
      box-sizing: border-box;
    }

    @media(max-width:880px) {
      .wrap {
        flex-direction: column;
        max-width: 100%;
        max-height: 100%;
        border-radius: 0;
      }
    }

    .game-area {
      flex: 1;
      min-width: 0;
      min-height: 0;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    canvas {
      background: transparent;
      width: 100%;
      height: 100%;
      display: block;
      border-radius: 8px;
      object-fit: contain;
    }

    .panel {
      width: 260px;
      flex-shrink: 0;
      padding: 12px;
      background: var(--panel);
      border-radius: 8px;
      display: flex;
      flex-direction: column;
      gap: 10px;
      align-items: stretch;
      overflow-y: auto;
      /* Allow panel scroll if really needed */
    }

    @media(max-width:880px) {
      .panel {
        width: auto;
        max-height: 40%;
        /* Limit panel height on mobile */
      }
    }

    .panel h2 {
      margin: 0;
      font-size: 18px;
      color: var(--accent)
    }

    .stats {
      display: flex;
      gap: 8px;
      flex-wrap: wrap
    }

    .stat {
      background: rgba(255, 255, 255, 0.03);
      padding: 8px;
      border-radius: 8px;
      font-size: 14px
    }

    .controls {
      display: flex;
      gap: 8px;
      flex-wrap: wrap
    }

    button {
      background: linear-gradient(180deg, var(--accent), #ff5f8e);
      border: none;
      color: white;
      padding: 8px 10px;
      border-radius: 8px;
      cursor: pointer
    }

    button.secondary {
      background: transparent;
      border: 1px solid rgba(255, 255, 255, 0.06);
    }

    .hint {
      font-size: 13px;
      color: #cbd5e1
    }

    .touch-controls {
      display: flex;
      gap: 8px;
      justify-content: center;
      margin-top: 6px
    }

    .touch-controls button {
      flex: 1;
      padding: 12px;
    }

    /* Larger touch targets */
    @media(max-width:880px) {
      .touch-controls {
        order: -1;
        margin-top: 0 !important;
        margin-bottom: 10px;
      }
    }
  </style>
</head>

<body>
  <div class="wrap">
    <div class="game-area">
      <canvas id="game"></canvas>
    </div>
    <aside class="panel">
      <h2>Beauty Invaders</h2>
      <div class="stats">
        <div class="stat">Punteggio: <span id="score">0</span></div>
        <div class="stat">Vite: <span id="lives">3</span></div>
        <div class="stat">Livello: <span id="level">1</span></div>
      </div>
      <div class="hint">
        Comandi: Muoviti con le <b>frecce</b> della tastiera, da mobile usa i tasti touch ◀ ▶ qui sotto. Premi
        <b>Space</b> per sparare.
      </div>

      <div class="controls">
        <button id="startBtn">Avvia / Riavvia</button>
        <button id="pauseBtn" class="secondary">Pausa</button>
      </div>

      <div style="margin-top:8px;">
        <strong>Obiettivo:</strong>
        elimina i prodotti prima che arrivino alla base, ma fai attenzione alle creme in vasetto in quanto tolgono
        punti!
      </div>

      <div class="touch-controls" style="margin-top:auto">
        <button id="leftTouch">◀</button>
        <button id="shootTouch">FIRE</button>
        <button id="rightTouch">▶</button>
      </div>

    </aside>
  </div>

  <script>
    /* -----------------------
       Beauty Invaders (single file)
       - Canvas game with falling "trucchi" (emoji)
       - Move left/right, shoot with space
       - Touch support for mobile
       ----------------------- */

    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d', { alpha: true });
    let W, H, scale;
    function resize() {
      // handle HiDPI
      const rect = canvas.getBoundingClientRect();
      W = Math.max(320, rect.width);
      H = Math.max(300, rect.height);
      scale = window.devicePixelRatio || 1;
      canvas.width = Math.floor(W * scale);
      canvas.height = Math.floor(H * scale);
      // canvas.style.width/height are handled by CSS now
      ctx.setTransform(scale, 0, 0, scale, 0, 0);
    }
    window.addEventListener('resize', resize);
    resize();

    /* Game state */
    let runLoop = null;
    let lastTime = 0;
    let game = {
      score: 0,
      lives: 3,
      level: 1,
      running: false,
      paused: false,
      spawnTimer: 0,
      spawnInterval: 1200, // ms
      difficultyTimer: 0
    };

    /* Player */
    const player = {
      w: 86,
      h: 86,
      x: 0,
      y: 0,
      speed: 420, // px/s
      color: '#ffdbe6',
      bullets: [],
      shootCooldown: 0,
      shootDelay: 300,
      img: new Image()
    };
    player.img.onload = () => draw();
    player.img.src = 'public/invaders/alien/alien-05.png';

    /* Falling items (trucchi) */
    const items = [];
    /* Falling items (trucchi) */
    const productTypes = [
      { src: 'public/invaders/products/product-01.png', score: 40, img: new Image() },
      { src: 'public/invaders/products/product-02.png', score: 30, img: new Image() },
      { src: 'public/invaders/products/product-03.png', score: 20, img: new Image() },
      { src: 'public/invaders/products/product-04.png', score: -15, img: new Image() }
    ];
    // Preload images
    productTypes.forEach(p => {
      if (p.src) {
        p.img.src = p.src;
      }
    });

    /* Helpers */
    function rand(min, max) { return Math.random() * (max - min) + min; }
    function spawnItem() {
      const pick = productTypes[Math.floor(Math.random() * productTypes.length)];
      const size = rand(70, 80); // slightly larger for images
      const item = {
        x: rand(20, W - 60),
        y: -50,
        size: size,
        score: pick.score,
        vy: rand(70, 150) + (game.level - 1) * 15,
        vx: rand(-20, 20),
        type: pick.type || 'product',
        img: pick.img
      };
      items.push(item);
    }

    /* Input */
    const keys = {};
    window.addEventListener('keydown', e => {
      keys[e.key] = true;
      if (e.key === ' ') { e.preventDefault(); }
    });
    window.addEventListener('keyup', e => {
      keys[e.key] = false;
    });
    /* Touch controls */
    document.getElementById('leftTouch').addEventListener('touchstart', e => { e.preventDefault(); keys['ArrowLeft'] = true; });
    document.getElementById('leftTouch').addEventListener('touchend', e => { e.preventDefault(); keys['ArrowLeft'] = false; });
    document.getElementById('leftTouch').addEventListener('mousedown', e => { e.preventDefault(); keys['ArrowLeft'] = true; });
    document.getElementById('leftTouch').addEventListener('mouseup', e => { e.preventDefault(); keys['ArrowLeft'] = false; });
    document.getElementById('rightTouch').addEventListener('touchstart', e => { e.preventDefault(); keys['ArrowRight'] = true; });
    document.getElementById('rightTouch').addEventListener('touchend', e => { e.preventDefault(); keys['ArrowRight'] = false; });
    document.getElementById('rightTouch').addEventListener('mousedown', e => { e.preventDefault(); keys['ArrowRight'] = true; });
    document.getElementById('rightTouch').addEventListener('mouseup', e => { e.preventDefault(); keys['ArrowRight'] = false; });
    document.getElementById('shootTouch').addEventListener('click', e => { keys[' '] = true; setTimeout(() => keys[' '] = false, 80); });

    /* UI */
    const scoreEl = document.getElementById('score');
    const livesEl = document.getElementById('lives');
    const levelEl = document.getElementById('level');
    document.getElementById('startBtn').addEventListener('click', startGame);
    document.getElementById('pauseBtn').addEventListener('click', togglePause);

    function startGame() {
      // reset
      game.score = 0; game.lives = 3; game.level = 1;
      game.spawnInterval = 1200; game.spawnTimer = 0; game.difficultyTimer = 0;
      items.length = 0; player.bullets.length = 0;
      player.shootCooldown = 0;
      game.running = true; game.paused = false;
      lastTime = performance.now();
      positionPlayer();
      loop(lastTime);
    }
    function togglePause() {
      if (!game.running) return;
      game.paused = !game.paused;
      if (!game.paused) { lastTime = performance.now(); loop(lastTime); }
    }

    /* Place player */
    function positionPlayer() {
      player.x = (W - player.w) / 2;
      player.y = H - player.h - 18;
    }

    /* Shooting */
    function shoot() {
      const now = performance.now();
      if (player.shootCooldown > now) return;
      player.shootCooldown = now + player.shootDelay;
      const b = {
        x: player.x + player.w / 2 - 4,
        y: player.y - 10,
        w: 6, h: 12, vy: -560
      };
      player.bullets.push(b);
    }

    /* Collisions (AABB) */
    function hit(a, b) {
      return !(a.x + a.w < b.x || a.x > b.x + b.w || a.y + a.h < b.y || a.y > b.y + b.h);
    }

    /* Main loop */
    function loop(t) {
      if (!game.running || game.paused) return;
      const dt = Math.min(40, t - lastTime); // ms
      const s = dt / 1000;
      lastTime = t;

      // update difficulty
      game.difficultyTimer += dt;
      if (game.difficultyTimer > 8000) {
        game.difficultyTimer = 0;
        game.level++;
        game.spawnInterval = Math.max(420, game.spawnInterval - 100);
      }

      // spawn items
      game.spawnTimer += dt;
      if (game.spawnTimer >= game.spawnInterval) {
        game.spawnTimer = 0;
        // spawn 1 or sometimes 2
        spawnItem();
        if (Math.random() < Math.min(0.25, game.level * 0.03)) spawnItem();
      }

      // player movement
      if (keys['ArrowLeft'] || keys['a']) player.x -= player.speed * s;
      if (keys['ArrowRight'] || keys['d']) player.x += player.speed * s;
      // bounds
      if (player.x < 6) player.x = 6;
      if (player.x + player.w > W - 6) player.x = W - 6 - player.w;

      // shooting
      if ((keys[' '] || keys['Spacebar'])) shoot();

      // update bullets
      for (let i = player.bullets.length - 1; i >= 0; i--) {
        const b = player.bullets[i];
        b.y += b.vy * s;
        if (b.y + b.h < -10) player.bullets.splice(i, 1);
      }

      // update items
      for (let i = items.length - 1; i >= 0; i--) {
        const it = items[i];
        it.x += it.vx * s;
        it.y += it.vy * s;
        // bounce a bit horizontally
        if (it.x < 6 || it.x + it.size > W - 6) it.vx *= -1;

        // check if reached bottom -> lose life
        if (it.y > H - 20 && it.score > 0) {
          items.splice(i, 1);
          game.lives -= 1;
          if (game.lives <= 0) { gameOver(); return; }
        } else {
          // check collision with bullets
          for (let j = player.bullets.length - 1; j >= 0; j--) {
            const b = player.bullets[j];
            const bb = { x: b.x, y: b.y, w: b.w, h: b.h };
            const ib = { x: it.x, y: it.y, w: it.size, h: it.size };
            if (hit(bb, ib)) {
              // hit!
              player.bullets.splice(j, 1);
              // reward
              game.score += it.score;
              // small chance to add extra life for high score hits
              if (Math.random() < 0.03) game.lives = Math.min(5, game.lives + 1);
              items.splice(i, 1);
              break;
            }
          }
        }
      }

      // UI update
      scoreEl.textContent = game.score;
      livesEl.textContent = game.lives;
      levelEl.textContent = game.level;

      // render
      draw();

      runLoop = requestAnimationFrame(loop);
    }

    /* Draw frame */
    function draw() {
      // clear
      ctx.clearRect(0, 0, W, H);
      // background vignette
      const g = ctx.createLinearGradient(0, 0, 0, H);
      g.addColorStop(0, 'rgba(255,255,255,0.02)');
      g.addColorStop(1, 'rgba(0,0,0,0.06)');
      ctx.fillStyle = g;
      ctx.fillRect(0, 0, W, H);

      // draw items
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      for (const it of items) {
        if (it.type === 'bomb') {
          ctx.fillStyle = '#ffffff';
          ctx.font = `${Math.floor(it.size)}px system-ui, sans-serif`;
          ctx.shadowColor = 'rgba(0,0,0,0.45)';
          ctx.shadowBlur = 6;
          ctx.fillText(it.emoji, it.x + it.size / 2, it.y + it.size / 2);
          ctx.shadowBlur = 0;
        } else {
          // Draw product image directly
          if (it.img && it.img.complete) {
            ctx.drawImage(it.img, it.x, it.y, it.size, it.size);
          } else {
            // Fallback
            ctx.fillStyle = '#fff';
            ctx.fillRect(it.x, it.y, it.size, it.size);
          }
        }
      }

      // draw player (alien svg)
      if (player.img.complete) {
        ctx.drawImage(player.img, player.x, player.y, player.w, player.h);
      }

      // bullets
      ctx.fillStyle = '#fff0';
      for (const b of player.bullets) {
        ctx.fillStyle = '#ffe6f1';
        roundRect(ctx, b.x, b.y, b.w, b.h, 3, true, false);
      }

      // HUD (top)
      ctx.fillStyle = 'rgba(255,255,255,0.02)';
      ctx.fillRect(6, 6, W - 12, 36);
    }

    /* Game over */
    function gameOver() {
      game.running = false;
      cancelAnimationFrame(runLoop);
      // draw final overlay
      ctx.fillStyle = 'rgba(2,6,23,0.7)';
      ctx.fillRect(0, 0, W, H);
      ctx.fillStyle = 'white';
      ctx.textAlign = 'center';
      ctx.font = '32px system-ui, serif';
      ctx.fillText('Game Over', W / 2, H / 2 - 24);
      ctx.font = '20px system-ui, serif';
      ctx.fillText(`Punteggio: ${game.score}`, W / 2, H / 2 + 8);
      ctx.font = '14px system-ui, serif';
      ctx.fillText('Premi AVVIA per giocare di nuovo', W / 2, H / 2 + 40);
    }

    /* Utility: rounded rect */
    function roundRect(ctx, x, y, w, h, r, fill, stroke) {
      if (typeof stroke === 'undefined') { stroke = true; }
      if (typeof r === 'undefined') { r = 5; }
      ctx.beginPath();
      ctx.moveTo(x + r, y);
      ctx.arcTo(x + w, y, x + w, y + h, r);
      ctx.arcTo(x + w, y + h, x, y + h, r);
      ctx.arcTo(x, y + h, x, y, r);
      ctx.arcTo(x, y, x + w, y, r);
      ctx.closePath();
      if (fill) ctx.fill();
      if (stroke) ctx.stroke();
    }

    /* initial */
    positionPlayer();
    draw();

    /* small keyboard pause binding */
    window.addEventListener('keydown', e => {
      if (e.key === 'p') togglePause();
      if (e.key === 'r') startGame();
    });

    /* auto start? no - wait for user */
  </script>
</body>

</html>